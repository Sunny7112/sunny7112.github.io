---
title: JVM 知识汇总
date: 2020-09-01 16:57:35
tags: JVM
---

## JVM 简介

​    JVM 是Java Virtual Machine的缩写。它是运行在操作系统之上的Java运行环境。它的目的是屏蔽操作系统之间API的差别，实现java语言可以跨平台运行， 所以针对各种操作系统都有对应的jdk实现版本。

![image-20200901171624384](JVM/image-20200901171624384.png)





## 一、JVM 内存模型以及分区

![image-20200901183859998](JVM/image-20200901183859998.png)

  JVM 运行时数据区分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中虚拟机栈、本地方法栈、程序计数器是线程私有的， 而方法区、堆是线程共享的，垃圾回收常常发生在堆中。

### 1. 程序计数器

程序计数器是一块较小的内存空间， 可以看作是当前线程所执行字节码的行号批示器。字节码解释器工作时通过改变这个计数器的值来选取下一条指令，分支、循环、跳转、异常处理、线程恢复等都要依赖这个计数器来完成。

### 2. Java虚拟机栈

- **虚拟机栈**是线程私有的，它的生命周期跟线程相同(随线程而生，随线程而灭)。

- 如果线程请求的栈深度大于虚拟机允许的最大深度， 将会抛出**StackOverflowError**；如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存，则会抛出**OutOfMemoryError**。

- Java虚拟机栈描述的是Java方法执行的内存模型，每个方法的调用会创建一个**栈桢**。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

  **局部变量表主要存放了编译期可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

### 3. 本地方法栈

它和虚拟机栈作用非常类似， Java虚拟机栈是为执行Java方法服务，本地方法栈是为执行native方法服务。它随地本方法调用而创建，本地方法返回而回收。

### 4. 堆

**堆**是线程共享的， 主要用来存放对象实例，数组，是进行垃圾回收主要区域。因些也叫**GC堆**

**Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。**

堆可以分为新生代，老年代，默认比例为1:2；  **–XX:NewRatio**

新生代又分为Eden区， S1， S2区,  其默认比例是8:1:1。**–XX:SurvivorRatio**

![image-20200902114315925](JVM/image-20200902114315925.png)



### 5. 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

虽然是线程共享的，但它是垃圾回收很少光顾的地方， 其垃圾回收主要是针对常量池以及类型卸载。

### 6. 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用） 

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

运行时常量池有一定的变动， 比如String.intern()方法会把字符串放进字符串常量池中。

### 7. 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。



## 二、 HotSpot虚拟机对象揭秘

### 1. 对象的创建过程

- **类加载检查** 

  当Java虚拟机执行new指令时， 首先会去检查这个指令的参数是否能在常量池中定位到对应类的符号引用， 并检查这个符号常量对应的类有没有被加载、解析、初始化过。如果没有则执行相应在类加载过程。

- **分配内存**

  类加载过程执行完成以后， 为对象要分配多大的内存也相应的确定下来了。 给对象分配内存际上就是在堆上分配一块内存给创建的对象。分配内存的方式有**空闲列表**和**指针碰撞**两种。

  给对象分配内存存在多线程同步问题。对象会首先在**TLAB**上分配内存， 如果TLAB不够或者对象过大，会用CAS的方式在新生代分配内存。

- **初始化零值**

  对象分配到内存以后， 会对分配到的内存进行初化默认值，这样以保证对象在未被初始化时也是可用的。

- **设置对象头**

  在初始化零值完成以后，会对对象头进行设置，比如对象是属于哪个类，对象的hascode, 对象的偏向锁信息，垃圾回收年龄信息等。

- **执行init方法**

  执行完设置对象头步骤以后， 就要进行Java对像的初始化工作了， 比如`<init>`, 构造方法里面的业务逻辑。

  

### 2. 对象的内存布局

HotSpot虚拟机对象包括3部分组成： **对象头**，**实例数据** ，**对齐填充**。

- **对象头**： HotSpoth虚拟机对象头包含两部分数据， 第一部分数据是对象运行时数据（哈希码，GC信息，锁状态标志等）第二部分是类的类对象指针， 虚拟机用来确定该对象是哪个类的实例。
- **实例数据**： 存储对象自身数据， 也就是程序中定义的各种属性数值。
- **对齐填充**：对齐填充不是必然存在的，也没有什么特殊意义仅起来占位作用。



### 3. 对象的访问定位





## 三、垃圾回收

### 1. 判定方法



### 2. 垃圾回收算法



### 3. Minor GC、Major GC、 Full GC



### 4. 垃圾收集器



## 四、类加载机制











