---
title: JVM
date: 2020-09-01 16:57:35
tags: JVM
---

## JVM 介绍

​    JVM 是Java Virtual Machine的缩写。它是运行在操作系统之上的Java运行环境。它的目的是屏蔽操作系统之间API的差别，实现java语言可以跨平台运行， 所以针对各种操作系统都有对应的jdk实现版本。

![image-20200901171624384](JVM/image-20200901171624384.png)





### JVM 内存模型以及分区

![image-20200901183859998](JVM/image-20200901183859998.png)

  JVM 运行时数据区分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中虚拟机栈、本地方法栈、程序计数器是线程私有的， 而方法区、堆是线程共享的，垃圾回收常常发生在堆中。

#### 1. 方法区

**方法区** 是线程共享的， 它主要用来存放类加载信息、常量、静态变量等。它被JVM定义为堆的一个逻辑部分，习惯上也被称为永久代。虽然是线程共享的，但它是垃圾回收很少光顾的地方， 其垃圾回收主要是针对常量池以及类型卸载。

常量池主要用来存放编译时生成的各种字节码以及符号引用，运行时常量池有一定的变动， 比如String.inter()方法会把字符串放进字符串常量池中。

#### 2. 堆

**堆**是线程共享的， 主要用来存放对象实例，数组，是进行垃圾回收主要区域。

堆可以分为新生代，老年代，默认比例为1:2；  **–XX:NewRatio**

新生代又分为Eden区， S1， S2区,  其默认比例是8:1:1。**–XX:SurvivorRatio**

最大

![image-20200902114315925](JVM/image-20200902114315925.png)

#### 3. 虚拟机栈

- **虚拟机栈**是线程私有的，它的生命周期跟线程相同(随线程而生，随线程而灭)。

- 如果线程请求的栈深度大于虚拟机允许的最大深度， 将会抛出**StackOverflowError**；如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存，则会抛出**OutOfMemoryError**。

- Java虚拟机栈描述的是Java方法执行的内存模型，每个方法的调用会创建一个**栈桢**。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

  **局部变量表主要存放了编译期可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

  

#### 4. 本地方法栈

它和虚拟机栈作用非常类似， Java虚拟机栈是为执行Java方法服务，本地方法栈是为执行native方法服务。它随地本方法调用而创建，本地方法返回而回收。



#### 5. 程序计数器

程序计数器是一块较小的内存空间， 可以看作是当前线程所执行字节码的行号批示器。字节码解释器工作时通过改变这个计数器的值来选取下一条指令，分支、循环、跳转、异常处理、线程恢复等都要依赖这个计数器来完成。











